---
title: Yarn の link protocol と alias
---

# Yarn の `link` protocol と alias

## tldr

Yarn の `link` protocol は、ローカルのパッケージが簡単に alias できて便利。  
でも pnpm にはそういうものは無いので、通常通り `workspace` protocol で install した後、`tsconfig.json` で `paths` を設定の上、ビルドツールにもそれを伝える必要がある。

## `link` protocol について

monorepo 構成で Yarn の Workspaces を使用している際、`link` protocol を使用することがあるかと思います。  
[Protocols | Yarn](https://yarnpkg.com/features/protocols)

パッケージ側でビルドを行う構成もあるかと思いますが、バージョニングやキャッシュなどの問題もあり管理が複雑化するので、シンプルに直接ソースを参照する構成も多いと思っていて、その時に使うイメージです。

以下のような構成の worksapce を想定します。

```
❯ tree -I node_modules -L 5
.
├── apps
│   └── web
│       ├── next-env.d.ts
│       ├── next.config.js
│       ├── package.json
│       ├── pages
│       │   └── index.tsx
│       └── tsconfig.json
├── package.json
├── packages
│   └── ui
│       ├── package.json
│       ├── src
│       │   └── Button.tsx
│       └── tsconfig.json
└── yarn.lock
```

ここで、ui の `Button` コンポーネントを web で例えば `@ui` として使用したい時、Yarn の `link` protocol を使うなら `package.json` に以下のように依存を示して `yarn install` します。

```json
"dependencies": {
  "@ui": "link:../../packages/ui/src"
}
```

すると、web のソースコードで以下のように `Button` を使用できるようになります。

```typescript
import { Button } from '@ui/Button';
```

仕組みは単純で、`node_modules/@ui` に `../../packages/ui/src` のシンボリックリンクが作成されることによって、それ以降特別な仕組み無しでモジュール解決ができるようになるというものです。  
VSCode の TypeScript Server 的にも、通常の依存の配置として正しいので、auto import できます。

これの嬉しいところですが、依存の install と同時に alias としても機能することです。  
例えばローカルパッケージをインストールする一番 basic な仕組みである `workspace` protocol で指定すると、パッケージ名はそのパッケージの `package.json` の `name` フィールドと一致している必要があります。  
つまり、ui パッケージの `name` が `@my-monorepo/ui` だった場合、`dependencies` には以下のように記載します。

```json
"dependencies": {
  "@my-monorepo/ui": "workspace:*"
}
```

すると、web のソースでは import 時に以下のように書く必要があります。

```typescript
import { Button } from '@my-monorepo/ui/src/Button';
```

使用者としては `src` ディレクトリにあることは知らなくていいし、そもそも長いですね。  
`link` protocol を使用しているときには直接 `src` に依存しているので、`@ui/Button` として参照できて便利です。

## pnpm にはない

個人で Yarn の Workspaces を使っていたリポジトリのパッケージマネージャーを pnpm に移行しようと思ったことがあったんですが、色々調べたところ、pnpm には `link` に相当する protocol やその他の仕組みが存在しませんでした。  
(多分無いんですが、もしあったらすいません)

そこで、pnpm を使って同じことをするにはちょっと設定が必要です。  
書いてみると当たり前のことなんですが、微妙に詰まったので一応書いておきます。

まず、そのまま `workspace` protocol で ui パッケージを指定して `pnpm i` します。

```json
"dependencies": {
  "@my-monorepo/ui": "workspace:*"
}
```

次に、`apps/web/tsconfig.json` で path alias を指定します。

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@ui/*": ["../../packages/ui/src/*"]
    }
    // ...otherOptions,
  }
  // ...otherOptions
}
```

これで、`link` protocol の時のように `@ui` パッケージのように使用できます。

```typescript
import { Button } from '@ui/Button';
```

また、ビルドツールが認識できるように設定ファイルにもこれを記載する必要がある場合があります。  
例えば Vite や Webpack を使用している場合は `resolve.alias` などで設定してください。  
Vite: [resolve.alias | Shared Options | Vite](https://vitejs.dev/config/shared-options.html#resolve-alias)  
Webpack: [Resolve | webpack](https://webpack.js.org/configuration/resolve/#resolvealias)

ちなみに Next.js ではなぜか zero config で解決できます。  
勝手に `tsconfig.json` を読んでいる 🤔

設定ファイルで `../../packages/ui/...` のようなことを書くたびに、なんかパッケージングの仕組みから逸脱してないか、、？と不安になることはあるんですが、まあ実際に逸脱しているのと、`link` protocol でもほぼ同じことをしているので、しょうがないですね (?)
